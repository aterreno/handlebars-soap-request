{
  "name": "Handlebars-soap-request",
  "tagline": "SOAP/XML request using a Handlebars template",
  "body": "# handlebars-soap-request\r\nSOAP/XML request using a Handlebars template.\r\n\r\nThis code only exists because I needed to handle a bunch of varied SOAP/XML service responses (some with namespaces, some without, soap11, soap12, etc...) and had to fall back to basics to get it working consistently.\r\n\r\nGenerate a sample service request using [SoapUI](http://www.soapui.org/) or something similar and then make a [Handlebars](http://handlebarsjs.com/) template from it.\r\n\r\n## Example usage\r\n\r\n\tvar soapRequest = require('handlebars-soap-request'); \r\n\t\r\n\tvar options = {\r\n\t\thandlebarsTemplate: '/path/to/my/template/file',\r\n\t\thandlebarsParams: jsonParams,\r\n\t\turl: 'http://my/service/endpoint'\r\n\t};\r\n\t\r\n\tsoapRequest(options, function(err, response) {\r\n\t\t\r\n\t});\r\n\r\n#### Default behaviour\r\n*\tSends a soap12 request. \r\n\r\n\tSpecify a soapAction (see options below) to send a soap11 request.\r\n\r\n*\tReturns a JSON response using the [basic-xml2json](https://www.npmjs.com/package/basic-xml2json) parser to parse the SOAP/XML.\r\n\r\n\tIf you don't want any XML parsing, set options.xmlResponse = true (see options below).\r\n\t\r\n*\tRegisters a \"cdata\"\tHandlebars helper that wraps the text with <![CDATA[ ... ]]>. You can use it something like this:\r\n\r\n\t\t<name>{{{cdata name}}}</name>\r\n\t\t\r\n*\tRegisters an \"xmldatetime\" Handlebars helper that formats a date in standard XML date/time format (YYYY-MM-DDTHH:mm:ss.SSSZ) or an alternate custom format. For example:\r\n\r\n\t\t<mytimestamp>{{{xmldatetime myDateTime}}}</mytimestamp>\r\n\t\t<mytimestamp>{{{xmldatetime myDateTime myAlternateFormat}}}</mytimestamp>\r\n\t\t\r\n\tIt uses [moment](http://momentjs.com/) to format the date/time.\r\n\t\r\n*\tRegisters an \"xmldatetimeoffset\" Handlerbars helper that offsets the date/time to something equivalent in a specific timezone. Ridiculous right! You might only need this if you are unlucky enough to deal with\r\n\tlegacy systems that don't deal with different timezones very well.\r\n\t\r\n\tIt allows you to capture something like 2015-12-29 12:30 GMT+06 and convert it to 2015-12-29 12:30 GMT+10. I.e. something that looks the same when viewed in a different timezone. You can use it like this:\r\n\t\r\n\t\t<mytimestamp>{{{xmldatetimeoffset myDateTime}}}</mytimestamp>\r\n\t\t<mytimestamp>{{{xmldatetimeoffset myDateTime mySourceTimezoneOffset}}}</mytimestamp>\r\n\t\t<mytimestamp>{{{xmldatetimeoffset myDateTime mySourceTimezoneOffset myTargetTimezone}}}</mytimestamp>\r\n\t\t<mytimestamp>{{{xmldatetimeoffset myDateTime mySourceTimezoneOffset myTargetTimezone myAlternateFormat}}}</mytimestamp>\r\n\t\t\r\n\tIf you don't specify a source timezone offset (mySourceTimezoneOffset) then myDateTime.getTimezoneOffset() will be used.\r\n\r\n\tIf you don't specify a target timezone (myTargetTimezone) then \"Australia/Melbourne\" will be used.\r\n\t\r\n\tIf you don't specify an alternate custom format then the standard XML date/time format (YYYY-MM-DDTHH:mm:ss.SSSZ) will be used.\r\n\r\n###### soapRequest:options\r\n*\turl\r\n\r\n\tMandatory. String. The service endpoint url.\r\n\t\r\n*\thandlebarsTemplate\r\n\r\n\tMandatory. String. The path to the Handlebars template file.\r\n\t\r\n*\thandlebarsParams\r\n\r\n\tOptional. Object. The JSON data to be provided to the Handlebars template\r\n\t\r\n*\thandlebarsPartials\r\n\r\n\tOptional. Array of { name: 'nameForPartial', filename: 'path/to/partial' }.\r\n\t\r\n\tPartial template files are loaded and registered under the specified name.\r\n\t\r\n*\tsoapAction\r\n\r\n\tOptional. String. If specified, a soap11 request will be sent. The SOAPAction header will contain the value specified here.\r\n\t\r\n*\trequestHeaders\r\n\r\n\tOptional. Object. If specified, will be used in place of the default soap12 or soap11 headers.\r\n\t\r\n*\txmlResponse\r\n\r\n\tOptional. Boolean. If true, the response will be the unaltered SOAP/XML body from the service.\r\n\t\r\n*\terrorLogger\r\n\r\n\tOptional. Function. The default error logging behaviour is to console.log the details. To override this you need to specify your own errorLogger like this:\r\n\t\r\n\t\t//The errorLogger function will be called before the service is invoked so that any initial setup can be done\r\n\t\tvar myErrorLogger = function(serviceName) {\r\n\t\t\tvar st = Date.now(); //E.g. We may want to remember the current time so we can log the duration of the failed service call\r\n\t\t\treturn {\r\n\t\t\t\t//The onError function is only called if an error is returned by the service (including unexpected SOAP Faults). This is where the error logging should happen\r\n\t\t\t\tonError: function(soapReq, errorResponse) {\r\n\t\t\t\t\tvar duration = Date.now() - st;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t};\r\n\t\r\n\t\tvar options = {\r\n\t\t\thandlebarsTemplate: '/path/to/my/template/file',\r\n\t\t\thandlebarsParams: jsonParams,\r\n\t\t\turl: 'http://my/service/endpoint',\r\n\t\t\terrorLogger: myErrorLogger\r\n\t\t};\r\n\t\r\n*\tserviceName\r\n\r\n\tOptional. String. If provided, will be passed to the start method of the error logger as the serviceName used to identify the service being invoked. If not provided, the url will be passed to the error logger instead.\r\n\t\r\n*\tisExpectedFault\r\n\r\n\tOptional. Function returning a boolean. If you need to recognise certain SOAP Faults as expected behaviour (not errors) then you can provide your own isExpectedFault function. Here is an example:\r\n\t\r\n\t\tfunction isExpectedFault(json) {\r\n\t\t\treturn !!xml2json.getChildNode(json.root, ['Body','Fault','Detail','SomeExpectedException']);\r\n\t\t}\r\n\t\r\n\t\tvar options = {\r\n\t\t\thandlebarsTemplate: '/path/to/my/template/file',\r\n\t\t\turl: 'http://my/service/endpoint',\r\n\t\t\tisExpectedFault: isExpectedFault\r\n\t\t};\r\n\t",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}